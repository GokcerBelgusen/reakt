{
  "name": "Reakt",
  "tagline": "Reactive interfaces. Promises, Streams, Callbacks, Async results, interfaces for Java that are lambda expression friendly and fluent.",
  "body": "\r\n***Reactive interfaces for Java.***\r\n\r\nReakt is reactive interfaces for Java which includes: \r\n * Promises,\r\n * Streams, \r\n * Callbacks, \r\n * Async results\r\n \r\nThe emphasis is on defining interfaces that enable lambda expressions, \r\nand fluent APIs for asynchronous programming for Java.\r\n\r\n\r\nNote: This mostly just provides the interfaces not the implementations. There are some starter implementations but the idea is that anyone can implement this. It is all about interfaces. There will be adapters for Vertx, RxJava, Reactive Streams, etc. There is support for ***Guava Async*** (used by Cassandra) and the ***QBit*** microservices lib. \r\n\r\n## Getting started\r\n#### Using from maven\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>io.advantageous</groupId>\r\n    <artifactId>reakt</artifactId>\r\n    <version>0.1.0</version>\r\n</dependency>\r\n```\r\n\r\n#### Using from gradle\r\n```xml\r\ncompile 'io.advantageous:reakt:0.1.0'\r\n```\r\n\r\n#### Fluent Promise API\r\n```java\r\n\r\n  Promise<Employee> promise = promise()\r\n                .then(e -> saveEmployee(e))\r\n                .catchError(error -> \r\n                     logger.error(\"Unable to lookup employee\", error));\r\n\r\n  employeeService.lookupEmployee(33, promise);\r\n```\r\n\r\nOr you can handle it in one line. \r\n\r\n#### Fluent Promise API example 2\r\n```java\r\n\r\n\r\n  employeeService.lookupEmployee(33, \r\n        promise().then(e -> saveEmployee(e))\r\n                 .catchError(error -> logger.error(\r\n                                           \"Unable to lookup \", error))\r\n        );\r\n```\r\n\r\n\r\nPromises are both a callback and a Result; however, you can work\r\nwith Callbacks directly. \r\n\r\n#### Using Result and callback directly\r\n```java\r\n        employeeService.lookupEmployee(33, result -> {\r\n            result.then(e -> saveEmployee(e))\r\n                  .catchError(error -> {\r\n                    logger.error(\"Unable to lookup\", error);\r\n            });\r\n        });\r\n```\r\n\r\nIn both of these examples, lookupEmployee would look like:\r\n\r\n#### Using Result and callback directly\r\n```java\r\n\r\n   public void lookupEmployee(long employeeId, Callback<Employee> callback){...}\r\n\r\n```\r\n\r\nYou can use Promises to transform into other promises. \r\n\r\n#### Transforming into another type of promise using thenMap\r\n```java\r\n\r\n        Promise<Employee> employeePromise = Promises.<Employee>blockingPromise();\r\n\r\n        Promise<Sheep> sheepPromise = employeePromise\r\n                .thenMap(employee1 -> new Sheep(employee1.getId()));\r\n```\r\n\r\nThe `thenMap` will return a new type of Promise. \r\n\r\nYou can find more examples in the [reakt wiki](https://github.com/advantageous/reakt/wiki).\r\n\r\nWe also support working with streams. \r\n\r\n\r\n## Promise concepts\r\n\r\nThis has been adapted from this [article on ES6 promises](http://www.html5rocks.com/en/tutorials/es6/promises/).\r\nA promise can be:\r\n\r\n* fulfilled The callback/action relating to the promise succeeded \r\n* rejected  The callback/action relating to the promise failed \r\n* pending   The callback/action has not been fulfilled or rejected yet \r\n* completed The callback/action has been fulfilled/resolved or rejected\r\n\r\nJava is not single threaded, meaning that two bits of code can run at \r\nthe same time, so the design of this promise and streaming library takes\r\nthat into account. \r\n\r\nThere are three types of promises:\r\n* Callback promises\r\n* Blocking promises (for testing and legacy integration)\r\n* Replay promises (allow promises to be handled on the same thread as caller)\r\n\r\nReplay promises are the most like their JS cousins. Replay promises are usually\r\nmanaged by the Reakt `Reactor` and supports environments like Vert.x and QBit.\r\nSee the wiki for more details on Replay promises.\r\n\r\nIt is common to make async calls to store data in \r\na NoSQL store or to call a remote REST interface or deal with a \r\ndistributed cache or queue. Also Java is strongly typed so the library\r\nthat mimics JS promises is going to look a bit different. We tried to \r\nuse similar terminology where it makes sense. \r\n\r\nEvents and Streams are great for things that can happen multiple times \r\non the same object â€” keyup, touchstart, or event a \r\nuser action stream from Kafka, etc. \r\n\r\nWith those events you don't really care about what happened before \r\nwhen you attached the listener. \r\n\r\nBut often times when dealing with services and data repositories,\r\nyou want to handle a response with a specific next action, \r\nand a different action if there was an error\r\nor timeout from the responses. You essentially want to call and handle\r\na response asynchronously and that is what promises allow.\r\n\r\nThis is not our first time to bat with Promises. QBit has had Promises for\r\na few years now. We just called them CallbackBuilders instead. \r\nWe wanted to use more standard terminology and wanted to use the same \r\nterminology and modeling on projects that do not use QBit like Conekt, \r\nVert.x, RxJava, and reactive streams.\r\n\r\nAt their most basic level, promises are like event listeners except:\r\n\r\nA promise can only succeed or fail once. A promise cannot succeed or \r\nfail twice, neither can it switch from \r\nsuccess to failure. Once it enters its `completed` state, then it is done.\r\n\r\n\r\n## Bridges\r\n\r\n[Reakt Guava Bridge](http://advantageous.github.io/reakt-guava/) which \r\nallows libs that use Guava async support to now have a modern Java feel.\r\n\r\n\r\n#### Cassandra Reakt example\r\n\r\n```java\r\n\r\nregister(session.executeAsync(\"SELECT release_version FROM system.local\"), \r\n  promise().thenRef(ref -> \r\n     gui.setMessage(\"Cassandra version is \" +\r\n         ref.get().one().getString(\"release_version\"))\r\n  ).catchError(error -> \r\n     gui.setMessage(\"Error while reading Cassandra version: \" \r\n     + error.getMessage())\r\n  )\r\n);\r\n     \r\n```\r\n\r\n***QBit 1*** ships with a bridge and ***QBit 2***will use ***Reakt*** as its \r\nprimary reactive callback mechanism. \r\n\r\n***Conekt***, a slimmed down fork of Vert.x, will also use ***Reakt***. \r\n\r\nSee [QBit](https://github.com/advantageous/qbit) microservices lib \r\nfor more details.\r\n\r\nSee our wiki for more details on [Reakt](https://github.com/advantageous/reakt/wiki).\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}