{
  "name": "Reakt",
  "tagline": "Reactive interfaces. Promises, Streams, Callbacks, Async results, interfaces for Java that are lambda expression friendly and fluent.",
  "body": "# reakt [![Build Status](https://travis-ci.org/advantageous/reakt.svg)](https://travis-ci.org/advantageous/reakt) [![Join the chat at https://gitter.im/advantageous/reakt](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/advantageous/reakt?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\n[Reakt website](http://advantageous.github.io/reakt)\r\n\r\nReactive interfaces for Java.\r\n\r\nReakt is reactive interfaces for Java: \r\n * Promises, \r\n * Streams, \r\n * Callbacks, \r\n * Async results\r\n \r\nThe emphasis is on defining interfaces that enable lambda expressions, \r\nand fluent APIs for asynchronous programming for Java.\r\n\r\n\r\nNote: This mostly just provides the interfaces not the implementations. There are some starter implementations but the idea is that anyone can implement this. It is all about interfaces. There will be adapters for Vertx, RxJava, Reactive Streams, Guava Async Futures, etc.\r\n\r\n#### Fluent Promise API\r\n```java\r\n\r\n  Promise<Employee> promise = promise()\r\n                .then(e -> saveEmployee(e))\r\n                .catchError(error -> \r\n                     logger.error(\"Unable to lookup employee\", error));\r\n\r\n  employeeService.lookupEmployee(33, promise);\r\n```\r\n\r\nOr you can handle it in one line. \r\n\r\n#### Fluent Promise API example 2\r\n```java\r\n\r\n\r\n  employeeService.lookupEmployee(33, \r\n        promise().then(e -> saveEmployee(e))\r\n                 .catchError(error -> logger.error(\r\n                                           \"Unable to lookup \", error))\r\n        );\r\n```\r\n\r\n\r\nPromises are both a callback and a Result; however, you can work\r\nwith Callbacks directly. \r\n\r\n#### Using Result and callback directly\r\n```java\r\n        employeeService.lookupEmployee(33, result -> {\r\n            result.then(e -> saveEmployee(e))\r\n                  .catchError(error -> {\r\n                    logger.error(\"Unable to lookup\", error);\r\n            });\r\n        });\r\n```\r\n\r\nIn both of these examples, lookupService would look like:\r\n\r\n#### Using Result and callback directly\r\n```java\r\n\r\n   public void lookup(long employeeId, Callback<Employee> callback){...}\r\n\r\n```\r\n\r\n\r\n## Bridges\r\n\r\n[Reakt Guava Bridge](http://advantageous.github.io/reakt-guava/) which \r\nallows libs that use Guava async support to now have a modern Java feel.\r\n\r\n\r\n#### Cassandra Reakt example\r\n\r\n```java\r\n\r\nregister(session.executeAsync(\"SELECT release_version FROM system.local\"), \r\n  promise().thenRef(ref -> \r\n     gui.setMessage(\"Cassandra version is \" +\r\n         ref.get().one().getString(\"release_version\"))\r\n  ).catchError(error -> \r\n     gui.setMessage(\"Error while reading Cassandra version: \" \r\n     + error.getMessage())\r\n  )\r\n);\r\n     \r\n```\r\n\r\n***QBit 1*** ships with a bridge and ***QBit 2***will use ***Reakt*** as its \r\nprimary reactive callback mechanism. \r\n\r\n***Conekt***, a slimmed down fork of Vert.x, will also use ***Reakt***. \r\n\r\nSee [QBit](https://github.com/advantageous/qbit) microservices lib \r\nfor more details.\r\n\r\nSee our wiki for more details on [Reakt](https://github.com/advantageous/reakt/wiki).\r\n\r\n\r\n## Further reading\r\n\r\n* [Reactive Programming](http://rick-hightower.blogspot.com/2015/03/reactive-programming-service-discovery.html)\r\n* [High-speed reactive microservices consulting firm and authors of QBit/Reakt with lots of experience with Vertx - Mammatus Technology](http://www.mammatustech.com/)\r\n* [Reactive Microservices](http://www.mammatustech.com/reactive-microservices)\r\n* [All code is written using JetBrains Idea - the best IDE ever!](https://www.jetbrains.com/idea/)\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}