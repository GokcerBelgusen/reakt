<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Reakt by advantageous</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Reakt</h1>
      <h2 class="project-tagline">Reactive interfaces. Promises, Streams, Callbacks, Async results, interfaces for Java that are lambda expression friendly and fluent.</h2>
      <a href="https://github.com/advantageous/reakt" class="btn">View on GitHub</a>
      <a href="https://github.com/advantageous/reakt/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/advantageous/reakt/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p><strong><em>Reactive interfaces for Java.</em></strong></p>

<p>Reakt is reactive interfaces for Java which includes: </p>

<ul>
<li>
<a href="https://github.com/advantageous/reakt/wiki/Promise">Promises</a>,</li>
<li>
<a href="https://github.com/advantageous/reakt/wiki/Stream">Streams</a>, </li>
<li>
<a href="https://github.com/advantageous/reakt/wiki/Callback">Callbacks</a>, </li>
<li>
<a href="https://github.com/advantageous/reakt/wiki/Result">Async Results</a> with <a href="https://github.com/advantageous/reakt/wiki/Expected">Expected</a>
</li>
<li><a href="https://github.com/advantageous/reakt/wiki/Breaker">Circuit Breakers</a></li>
</ul>

<p>The emphasis is on defining interfaces that enable lambda expressions, 
and fluent APIs for asynchronous programming for Java.</p>

<p>Note: This mostly just provides the interfaces not the implementations. There are some starter implementations but the idea is that anyone can implement this. It is all about interfaces. There will be adapters for Vertx, RxJava, Reactive Streams, etc. There is support for <strong><em>Guava Async</em></strong> (used by Cassandra) and the <strong><em>QBit</em></strong> microservices lib. <a href="http://advantageous.github.io/czar-maker/">Czar Maker</a> uses Reakt for its reactive leadership election.</p>

<h2>
<a id="have-a-question" class="anchor" href="#have-a-question" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Have a question?</h2>

<p><a href="https://groups.google.com/forum/#!forum/reakt">Reakt Mailing List</a></p>

<h2>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Getting started</h2>

<h4>
<a id="using-from-maven" class="anchor" href="#using-from-maven" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using from maven</h4>

<div class="highlight highlight-text-xml"><pre>&lt;<span class="pl-ent">dependency</span>&gt;
    &lt;<span class="pl-ent">groupId</span>&gt;io.advantageous&lt;/<span class="pl-ent">groupId</span>&gt;
    &lt;<span class="pl-ent">artifactId</span>&gt;reakt&lt;/<span class="pl-ent">artifactId</span>&gt;
    &lt;<span class="pl-ent">version</span>&gt;2.0.0.RELEASE&lt;/<span class="pl-ent">version</span>&gt;
&lt;/<span class="pl-ent">dependency</span>&gt;</pre></div>

<h4>
<a id="using-from-gradle" class="anchor" href="#using-from-gradle" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using from gradle</h4>

<div class="highlight highlight-text-xml"><pre>compile 'io.advantageous:reakt:2.0.0.RELEASE'</pre></div>

<h4>
<a id="fluent-promise-api" class="anchor" href="#fluent-promise-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Fluent Promise API</h4>

<div class="highlight highlight-source-java"><pre>
  <span class="pl-k">Promise&lt;<span class="pl-smi">Employee</span>&gt;</span> promise <span class="pl-k">=</span> promise()
                .then(e <span class="pl-k">-</span><span class="pl-k">&gt;</span> saveEmployee(e))
                .catchError(error <span class="pl-k">-</span><span class="pl-k">&gt;</span> 
                     logger<span class="pl-k">.</span>error(<span class="pl-s"><span class="pl-pds">"</span>Unable to lookup employee<span class="pl-pds">"</span></span>, error));

  employeeService<span class="pl-k">.</span>lookupEmployee(<span class="pl-c1">33</span>, promise);</pre></div>

<p>Or you can handle it in one line. </p>

<h4>
<a id="fluent-promise-api-example-2" class="anchor" href="#fluent-promise-api-example-2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Fluent Promise API example 2</h4>

<div class="highlight highlight-source-java"><pre>

  employeeService<span class="pl-k">.</span>lookupEmployee(<span class="pl-c1">33</span>, 
        promise()<span class="pl-k">.</span>then(e <span class="pl-k">-</span><span class="pl-k">&gt;</span> saveEmployee(e))
                 .catchError(error <span class="pl-k">-</span><span class="pl-k">&gt;</span> logger<span class="pl-k">.</span>error(
                                           <span class="pl-s"><span class="pl-pds">"</span>Unable to lookup <span class="pl-pds">"</span></span>, error))
        );</pre></div>

<p>Promises are both a callback and a Result; however, you can work
with Callbacks directly. </p>

<h4>
<a id="using-result-and-callback-directly" class="anchor" href="#using-result-and-callback-directly" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using Result and callback directly</h4>

<div class="highlight highlight-source-java"><pre>        employeeService<span class="pl-k">.</span>lookupEmployee(<span class="pl-c1">33</span>, result <span class="pl-k">-</span><span class="pl-k">&gt;</span> {
            result<span class="pl-k">.</span>then(e <span class="pl-k">-</span><span class="pl-k">&gt;</span> saveEmployee(e))
                  .catchError(error <span class="pl-k">-</span><span class="pl-k">&gt;</span> {
                    logger<span class="pl-k">.</span>error(<span class="pl-s"><span class="pl-pds">"</span>Unable to lookup<span class="pl-pds">"</span></span>, error);
            });
        });</pre></div>

<p>In both of these examples, lookupEmployee would look like:</p>

<h4>
<a id="using-result-and-callback-directly-1" class="anchor" href="#using-result-and-callback-directly-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using Result and callback directly</h4>

<div class="highlight highlight-source-java"><pre>
   <span class="pl-k">public</span> <span class="pl-k">void</span> lookupEmployee(<span class="pl-k">long</span> employeeId, <span class="pl-k">Callback&lt;<span class="pl-smi">Employee</span>&gt;</span> callback){<span class="pl-c1">...</span>}
</pre></div>

<p>You can use Promises to transform into other promises. </p>

<h4>
<a id="transforming-into-another-type-of-promise-using-thenmap" class="anchor" href="#transforming-into-another-type-of-promise-using-thenmap" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Transforming into another type of promise using thenMap</h4>

<div class="highlight highlight-source-java"><pre>
        <span class="pl-k">Promise&lt;<span class="pl-smi">Employee</span>&gt;</span> employeePromise <span class="pl-k">=</span> <span class="pl-smi">Promises</span><span class="pl-k">.</span><span class="pl-k">&lt;</span><span class="pl-smi">Employee</span><span class="pl-k">&gt;</span>blockingPromise();

        <span class="pl-k">Promise&lt;<span class="pl-smi">Sheep</span>&gt;</span> sheepPromise <span class="pl-k">=</span> employeePromise
                .thenMap(employee1 <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-k">new</span> <span class="pl-smi">Sheep</span>(employee1<span class="pl-k">.</span>getId()));</pre></div>

<p>The <code>thenMap</code> will return a new type of Promise. </p>

<p>You can find more examples in the <a href="https://github.com/advantageous/reakt/wiki">reakt wiki</a>.</p>

<p>We also support working with streams. </p>

<h2>
<a id="promise-concepts" class="anchor" href="#promise-concepts" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Promise concepts</h2>

<p>This has been adapted from this <a href="http://www.html5rocks.com/en/tutorials/es6/promises/">article on ES6 promises</a>.
A promise can be:</p>

<ul>
<li>fulfilled The callback/action relating to the promise succeeded </li>
<li>rejected  The callback/action relating to the promise failed </li>
<li>pending   The callback/action has not been fulfilled or rejected yet </li>
<li>completed The callback/action has been fulfilled/resolved or rejected</li>
</ul>

<p>Java is not single threaded, meaning that two bits of code can run at 
the same time, so the design of this promise and streaming library takes
that into account. </p>

<p>There are three types of promises:</p>

<ul>
<li>Callback promises</li>
<li>Blocking promises (for testing and legacy integration)</li>
<li>Replay promises (allow promises to be handled on the same thread as caller)</li>
</ul>

<p>Replay promises are the most like their JS cousins. Replay promises are usually
managed by the Reakt <code>Reactor</code> and supports environments like Vert.x and QBit.
See the wiki for more details on Replay promises.</p>

<p>It is common to make async calls to store data in 
a NoSQL store or to call a remote REST interface or deal with a 
distributed cache or queue. Also Java is strongly typed so the library
that mimics JS promises is going to look a bit different. We tried to 
use similar terminology where it makes sense. </p>

<p>Events and Streams are great for things that can happen multiple times 
on the same object — keyup, touchstart, or event a 
user action stream from Kafka, etc. </p>

<p>With those events you don't really care about what happened before 
when you attached the listener. </p>

<p>But often times when dealing with services and data repositories,
you want to handle a response with a specific next action, 
and a different action if there was an error
or timeout from the responses. You essentially want to call and handle
a response asynchronously and that is what promises allow.</p>

<p>This is not our first time to bat with Promises. QBit has had Promises for
a few years now. We just called them CallbackBuilders instead. 
We wanted to use more standard terminology and wanted to use the same 
terminology and modeling on projects that do not use QBit like Conekt, 
Vert.x, RxJava, and reactive streams.</p>

<p>At their most basic level, promises are like event listeners except:</p>

<p>A promise can only succeed or fail once. A promise cannot succeed or 
fail twice, neither can it switch from 
success to failure. Once it enters its <code>completed</code> state, then it is done.</p>

<h2>
<a id="bridges" class="anchor" href="#bridges" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Bridges</h2>

<p><a href="http://advantageous.github.io/reakt-guava/">Reakt Guava Bridge</a> which 
allows libs that use Guava async support to now have a modern Java feel.</p>

<h4>
<a id="cassandra-reakt-example" class="anchor" href="#cassandra-reakt-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Cassandra Reakt example</h4>

<div class="highlight highlight-source-java"><pre>
register(session<span class="pl-k">.</span>executeAsync(<span class="pl-s"><span class="pl-pds">"</span>SELECT release_version FROM system.local<span class="pl-pds">"</span></span>), 
  promise()<span class="pl-k">.</span>thenExpect(expected <span class="pl-k">-</span><span class="pl-k">&gt;</span> 
     gui<span class="pl-k">.</span>setMessage(<span class="pl-s"><span class="pl-pds">"</span>Cassandra version is <span class="pl-pds">"</span></span> <span class="pl-k">+</span>
         expected<span class="pl-k">.</span>get()<span class="pl-k">.</span>one()<span class="pl-k">.</span>getString(<span class="pl-s"><span class="pl-pds">"</span>release_version<span class="pl-pds">"</span></span>))
  )<span class="pl-k">.</span>catchError(error <span class="pl-k">-</span><span class="pl-k">&gt;</span> 
     gui<span class="pl-k">.</span>setMessage(<span class="pl-s"><span class="pl-pds">"</span>Error while reading Cassandra version: <span class="pl-pds">"</span></span> 
     <span class="pl-k">+</span> error<span class="pl-k">.</span>getMessage())
  )
);
</pre></div>

<p><strong><em>QBit 1</em></strong> ships with a bridge and <strong><em>QBit 2</em></strong>will use <strong><em>Reakt</em></strong> as its 
primary reactive callback mechanism. </p>

<p><strong><em>Conekt</em></strong>, a slimmed down fork of Vert.x, will also use <strong><em>Reakt</em></strong>. </p>

<p>See <a href="https://github.com/advantageous/qbit">QBit</a> microservices lib 
for more details.</p>

<p>See our wiki for more details on <a href="https://github.com/advantageous/reakt/wiki">Reakt</a>.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/advantageous/reakt">Reakt</a> is maintained by <a href="https://github.com/advantageous">advantageous</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
